class o{_locked=!1;_waitQueue=[];async lock(){if(!this._locked){this._locked=!0;return}return new Promise((p)=>{this._waitQueue.push(p)})}unlock(){if(!this._locked)throw Error("Mutex: unlock of unlocked mutex");if(this._waitQueue.length>0){let p=this._waitQueue.shift();if(p)p()}else this._locked=!1}tryLock(){if(this._locked)return!1;return this._locked=!0,!0}get locked(){return this._locked}}class m{_writeLocked=!1;_readCount=0;_writeWaitQueue=[];_readWaitQueue=[];async lock(){if(!this._writeLocked&&this._readCount===0){this._writeLocked=!0;return}return new Promise((p)=>{this._writeWaitQueue.push(p)})}unlock(){if(!this._writeLocked)throw Error("RWMutex: unlock of unlocked write mutex");this._writeLocked=!1,this._processWaitQueue()}async rlock(){if(!this._writeLocked&&this._writeWaitQueue.length===0){this._readCount++;return}return new Promise((p)=>{this._readWaitQueue.push(()=>{this._readCount++,p()})})}runlock(){if(this._readCount===0)throw Error("RWMutex: runlock of unlocked read mutex");if(this._readCount--,this._readCount===0)this._processWaitQueue()}tryLock(){if(this._writeLocked||this._readCount>0)return!1;return this._writeLocked=!0,!0}tryRLock(){if(this._writeLocked||this._writeWaitQueue.length>0)return!1;return this._readCount++,!0}_processWaitQueue(){if(this._writeWaitQueue.length>0&&this._readCount===0){let p=this._writeWaitQueue.shift();if(p)this._writeLocked=!0,p()}else if(this._readWaitQueue.length>0&&!this._writeLocked)this._readWaitQueue.splice(0).forEach((f)=>f())}get readCount(){return this._readCount}get writeLocked(){return this._writeLocked}}class x{_counter=0;_waiters=[];add(p){if(this._counter+=p,this._counter<0)throw Error("WaitGroup: negative counter");if(this._counter===0)this._waiters.splice(0).forEach((M)=>M())}done(){this.add(-1)}async wait(){if(this._counter===0)return;return new Promise((p)=>{this._waiters.push(p)})}get counter(){return this._counter}}class j{_permits;_waitQueue=[];constructor(p){if(p<0)throw Error("Semaphore: permits must be non-negative");this._permits=p}async acquire(){if(this._permits>0){this._permits--;return}return new Promise((p)=>{this._waitQueue.push(p)})}release(){if(this._waitQueue.length>0){let p=this._waitQueue.shift();if(p)p()}else this._permits++}tryAcquire(){if(this._permits>0)return this._permits--,!0;return!1}get availablePermits(){return this._permits}get queueLength(){return this._waitQueue.length}}class I{_buffer=[];_capacity;_closed=!1;_sendWaiters=[];_receiveWaiters=[];constructor(p=0){if(p<0)throw Error("Channel: capacity must be non-negative");this._capacity=p}async send(p){if(this._closed)throw Error("Channel: send on closed channel");if(this._receiveWaiters.length>0){let f=this._receiveWaiters.shift();if(f){f.resolve(p);return}}if(this._capacity>0&&this._buffer.length<this._capacity){this._buffer.push(p);return}return new Promise((f)=>{this._sendWaiters.push({value:p,resolve:f})})}async receive(){if(this._buffer.length>0){let p=this._buffer.shift();return this._processSendWaiters(),p}if(this._sendWaiters.length>0){let p=this._sendWaiters.shift();if(p)return p.resolve(),p.value}if(this._closed)throw Error("Channel: receive from closed channel");return new Promise((p)=>{this._receiveWaiters.push({resolve:p})})}close(){if(this._closed)return;this._closed=!0,this._sendWaiters.forEach(()=>{}),this._sendWaiters.length=0}tryReceive(){if(this._buffer.length>0){let p=this._buffer.shift();return this._processSendWaiters(),p}if(this._sendWaiters.length>0){let p=this._sendWaiters.shift();if(p)return p.resolve(),p.value}return}trySend(p){if(this._closed)return!1;if(this._receiveWaiters.length>0){let f=this._receiveWaiters.shift();if(f)return f.resolve(p),!0}if(this._capacity>0&&this._buffer.length<this._capacity)return this._buffer.push(p),!0;return!1}_processSendWaiters(){while(this._buffer.length<this._capacity&&this._sendWaiters.length>0){let p=this._sendWaiters.shift();if(p)this._buffer.push(p.value),p.resolve()}}get length(){return this._buffer.length}get capacity(){return this._capacity}get closed(){return this._closed}}class y{_mutex;_waiters=[];constructor(p){this._mutex=p}async wait(){this._mutex.unlock(),await new Promise((p)=>{this._waiters.push(p)}),await this._mutex.lock()}signal(){if(this._waiters.length>0){let p=this._waiters.shift();if(p)setTimeout(p,0)}}broadcast(){if(this._waiters.length>0)this._waiters.splice(0).forEach((f)=>{setTimeout(f,0)})}get waitersCount(){return this._waiters.length}}export{x as WaitGroup,j as Semaphore,m as RWMutex,o as Mutex,y as Cond,I as Channel};
