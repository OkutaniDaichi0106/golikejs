class I{#j=!1;#x=[];async lock(){if(!this.#j){this.#j=!0;return}return new Promise((j)=>{this.#x.push(j)})}unlock(){if(!this.#j)throw Error("Mutex: unlock of unlocked mutex");if(this.#x.length>0){let j=this.#x.shift();if(j)j()}else this.#j=!1}tryLock(){if(this.#j)return!1;return this.#j=!0,!0}get locked(){return this.#j}}class M{#j=!1;#x=0;#M=[];#I=[];async lock(){if(!this.#j&&this.#x===0){this.#j=!0;return}return new Promise((j)=>{this.#M.push(j)})}unlock(){if(!this.#j)throw Error("RWMutex: unlock of unlocked write mutex");this.#j=!1,this.#R()}async rlock(){if(!this.#j&&this.#M.length===0){this.#x++;return}return new Promise((j)=>{this.#I.push(()=>{this.#x++,j()})})}runlock(){if(this.#x===0)throw Error("RWMutex: runlock of unlocked read mutex");if(this.#x--,this.#x===0)this.#R()}tryLock(){if(this.#j||this.#x>0)return!1;return this.#j=!0,!0}tryRLock(){if(this.#j||this.#M.length>0)return!1;return this.#x++,!0}#R(){if(this.#M.length>0&&this.#x===0){let j=this.#M.shift();if(j)this.#j=!0,j()}else if(this.#I.length>0&&!this.#j)this.#I.splice(0).forEach((x)=>x())}get readCount(){return this.#x}get writeLocked(){return this.#j}}class R{#j=0;#x=[];add(j){if(this.#j+=j,this.#j<0)throw Error("WaitGroup: negative counter");if(this.#j===0)this.#x.splice(0).forEach((z)=>z())}done(){this.add(-1)}async wait(){if(this.#j===0)return;return new Promise((j)=>{this.#x.push(j)})}get counter(){return this.#j}}class S{#j;#x=[];constructor(j){if(j<0)throw Error("Semaphore: permits must be non-negative");this.#j=j}async acquire(){if(this.#j>0){this.#j--;return}return new Promise((j)=>{this.#x.push(j)})}release(){if(this.#x.length>0){let j=this.#x.shift();if(j)j()}else this.#j++}tryAcquire(){if(this.#j>0)return this.#j--,!0;return!1}get availablePermits(){return this.#j}get queueLength(){return this.#x.length}}class h{#j=[];#x;#M=!1;#I=[];#R=[];constructor(j=0){if(j<0)throw Error("Channel: capacity must be non-negative");this.#x=j}async send(j){if(this.#M)throw Error("Channel: send on closed channel");if(this.#R.length>0){let x=this.#R.shift();if(x){x.resolve(j);return}}if(this.#x>0&&this.#j.length<this.#x){this.#j.push(j);return}return new Promise((x)=>{this.#I.push({value:j,resolve:x})})}async receive(){if(this.#j.length>0){let j=this.#j.shift();return this.#S(),j}if(this.#I.length>0){let j=this.#I.shift();if(j)return j.resolve(),j.value}if(this.#M)throw Error("Channel: receive from closed channel");return new Promise((j)=>{this.#R.push({resolve:j})})}close(){if(this.#M)return;this.#M=!0,this.#I.forEach(()=>{}),this.#I.length=0}tryReceive(){if(this.#j.length>0){let j=this.#j.shift();return this.#S(),j}if(this.#I.length>0){let j=this.#I.shift();if(j)return j.resolve(),j.value}return}trySend(j){if(this.#M)return!1;if(this.#R.length>0){let x=this.#R.shift();if(x)return x.resolve(j),!0}if(this.#x>0&&this.#j.length<this.#x)return this.#j.push(j),!0;return!1}#S(){while(this.#j.length<this.#x&&this.#I.length>0){let j=this.#I.shift();if(j)this.#j.push(j.value),j.resolve()}}get length(){return this.#j.length}get capacity(){return this.#x}get closed(){return this.#M}}class p{#j;#x=[];constructor(j){this.#j=j}async wait(){this.#j.unlock(),await new Promise((j)=>{this.#x.push(j)}),await this.#j.lock()}signal(){if(this.#x.length>0){let j=this.#x.shift();if(j)setTimeout(j,0)}}broadcast(){if(this.#x.length>0)this.#x.splice(0).forEach((x)=>{setTimeout(x,0)})}get waitersCount(){return this.#x.length}}export{R as WaitGroup,S as Semaphore,M as RWMutex,I as Mutex,p as Cond,h as Channel};
