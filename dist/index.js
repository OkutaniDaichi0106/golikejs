class z{#M=!1;#j=[];async lock(){if(!this.#M){this.#M=!0;return}return new Promise((M)=>{this.#j.push(M)})}unlock(){if(!this.#M)throw Error("Mutex: unlock of unlocked mutex");if(this.#j.length>0){let M=this.#j.shift();if(M)M()}else this.#M=!1}tryLock(){if(this.#M)return!1;return this.#M=!0,!0}get locked(){return this.#M}}class I{#M=!1;#j=0;#I=[];#z=[];async lock(){if(!this.#M&&this.#j===0){this.#M=!0;return}return new Promise((M)=>{this.#I.push(M)})}unlock(){if(!this.#M)throw Error("RWMutex: unlock of unlocked write mutex");this.#M=!1,this.#J()}async rlock(){if(!this.#M&&this.#I.length===0){this.#j++;return}return new Promise((M)=>{this.#z.push(()=>{this.#j++,M()})})}runlock(){if(this.#j===0)throw Error("RWMutex: runlock of unlocked read mutex");if(this.#j--,this.#j===0)this.#J()}tryLock(){if(this.#M||this.#j>0)return!1;return this.#M=!0,!0}tryRLock(){if(this.#M||this.#I.length>0)return!1;return this.#j++,!0}#J(){if(this.#I.length>0&&this.#j===0){let M=this.#I.shift();if(M)this.#M=!0,M()}else if(this.#z.length>0&&!this.#M)this.#z.splice(0).forEach((j)=>j())}get readCount(){return this.#j}get writeLocked(){return this.#M}}class J{#M=0;#j=[];add(M){if(this.#M+=M,this.#M<0)throw Error("WaitGroup: negative counter");if(this.#M===0)this.#j.splice(0).forEach((q)=>q())}done(){this.add(-1)}async wait(){if(this.#M===0)return;return new Promise((M)=>{this.#j.push(M)})}get counter(){return this.#M}}class R{#M;#j=[];constructor(M){if(M<0)throw Error("Semaphore: permits must be non-negative");this.#M=M}async acquire(){if(this.#M>0){this.#M--;return}return new Promise((M)=>{this.#j.push(M)})}release(){if(this.#j.length>0){let M=this.#j.shift();if(M)M()}else this.#M++}tryAcquire(){if(this.#M>0)return this.#M--,!0;return!1}get availablePermits(){return this.#M}get queueLength(){return this.#j.length}}class S{#M=[];#j;#I=!1;#z=[];#J=[];constructor(M=0){if(M<0)throw Error("Channel: capacity must be non-negative");this.#j=M}async send(M){if(this.#I)throw Error("Channel: send on closed channel");if(this.#J.length>0){let j=this.#J.shift();if(j){j.resolve(M);return}}if(this.#j>0&&this.#M.length<this.#j){this.#M.push(M);return}return new Promise((j)=>{this.#z.push({value:M,resolve:j})})}async receive(){if(this.#M.length>0){let M=this.#M.shift();return this.#R(),M}if(this.#z.length>0){let M=this.#z.shift();if(M)return M.resolve(),M.value}if(this.#I)throw Error("Channel: receive from closed channel");return new Promise((M)=>{this.#J.push({resolve:M})})}close(){if(this.#I)return;this.#I=!0,this.#z.forEach(()=>{}),this.#z.length=0}tryReceive(){if(this.#M.length>0){let M=this.#M.shift();return this.#R(),M}if(this.#z.length>0){let M=this.#z.shift();if(M)return M.resolve(),M.value}return}trySend(M){if(this.#I)return!1;if(this.#J.length>0){let j=this.#J.shift();if(j)return j.resolve(M),!0}if(this.#j>0&&this.#M.length<this.#j)return this.#M.push(M),!0;return!1}#R(){while(this.#M.length<this.#j&&this.#z.length>0){let M=this.#z.shift();if(M)this.#M.push(M.value),M.resolve()}}get length(){return this.#M.length}get capacity(){return this.#j}get closed(){return this.#I}}class T{#M;#j=[];constructor(M){this.#M=M}async wait(){this.#M.unlock(),await new Promise((M)=>{this.#j.push(M)}),await this.#M.lock()}signal(){if(this.#j.length>0){let M=this.#j.shift();if(M)setTimeout(M,0)}}broadcast(){if(this.#j.length>0)this.#j.splice(0).forEach((j)=>{setTimeout(j,0)})}get waitersCount(){return this.#j.length}}export{J as WaitGroup,R as Semaphore,I as RWMutex,z as Mutex,T as Cond,S as Channel};
