class J{#M=!1;#z=[];async lock(){if(!this.#M){this.#M=!0;return}return new Promise((M)=>{this.#z.push(M)})}unlock(){if(!this.#M)throw Error("Mutex: unlock of unlocked mutex");if(this.#z.length>0){let M=this.#z.shift();if(M)M()}else this.#M=!1}tryLock(){if(this.#M)return!1;return this.#M=!0,!0}get locked(){return this.#M}}class R{#M=!1;#z=0;#R=[];#J=[];async lock(){if(!this.#M&&this.#z===0){this.#M=!0;return}return new Promise((M)=>{this.#R.push(M)})}unlock(){if(!this.#M)throw Error("RWMutex: unlock of unlocked write mutex");this.#M=!1,this.#S()}async rlock(){if(!this.#M&&this.#R.length===0){this.#z++;return}return new Promise((M)=>{this.#J.push(()=>{this.#z++,M()})})}runlock(){if(this.#z===0)throw Error("RWMutex: runlock of unlocked read mutex");if(this.#z--,this.#z===0)this.#S()}tryLock(){if(this.#M||this.#z>0)return!1;return this.#M=!0,!0}tryRLock(){if(this.#M||this.#R.length>0)return!1;return this.#z++,!0}#S(){if(this.#R.length>0&&this.#z===0){let M=this.#R.shift();if(M)this.#M=!0,M()}else if(this.#J.length>0&&!this.#M)this.#J.splice(0).forEach((z)=>z())}get readCount(){return this.#z}get writeLocked(){return this.#M}}class S{#M=0;#z=[];add(M){if(this.#M+=M,this.#M<0)throw Error("WaitGroup: negative counter");if(this.#M===0)this.#z.splice(0).forEach((B)=>B())}done(){this.add(-1)}async wait(){if(this.#M===0)return;return new Promise((M)=>{this.#z.push(M)})}get counter(){return this.#M}}class T{#M;#z=[];constructor(M){if(M<0)throw Error("Semaphore: permits must be non-negative");this.#M=M}async acquire(){if(this.#M>0){this.#M--;return}return new Promise((M)=>{this.#z.push(M)})}release(){if(this.#z.length>0){let M=this.#z.shift();if(M)M()}else this.#M++}tryAcquire(){if(this.#M>0)return this.#M--,!0;return!1}get availablePermits(){return this.#M}get queueLength(){return this.#z.length}}class q{#M=[];#z;#R=!1;#J=[];#S=[];constructor(M=0){if(M<0)throw Error("Channel: capacity must be non-negative");this.#z=M}async send(M){if(this.#R)throw Error("Channel: send on closed channel");if(this.#S.length>0){let z=this.#S.shift();if(z){z.resolve(M);return}}if(this.#z>0&&this.#M.length<this.#z){this.#M.push(M);return}return new Promise((z)=>{this.#J.push({value:M,resolve:z})})}async receive(){if(this.#M.length>0){let M=this.#M.shift();return this.#T(),M}if(this.#J.length>0){let M=this.#J.shift();if(M)return M.resolve(),M.value}if(this.#R)throw Error("Channel: receive from closed channel");return new Promise((M)=>{this.#S.push({resolve:M})})}close(){if(this.#R)return;this.#R=!0,this.#J.forEach(()=>{}),this.#J.length=0}tryReceive(){if(this.#M.length>0){let M=this.#M.shift();return this.#T(),M}if(this.#J.length>0){let M=this.#J.shift();if(M)return M.resolve(),M.value}return}trySend(M){if(this.#R)return!1;if(this.#S.length>0){let z=this.#S.shift();if(z)return z.resolve(M),!0}if(this.#z>0&&this.#M.length<this.#z)return this.#M.push(M),!0;return!1}#T(){while(this.#M.length<this.#z&&this.#J.length>0){let M=this.#J.shift();if(M)this.#M.push(M.value),M.resolve()}}get length(){return this.#M.length}get capacity(){return this.#z}get closed(){return this.#R}}class A{#M;#z=[];constructor(M){this.#M=M}async wait(){this.#M.unlock(),await new Promise((M)=>{this.#z.push(M)}),await this.#M.lock()}signal(){if(this.#z.length>0){let M=this.#z.shift();if(M)setTimeout(M,0)}}broadcast(){if(this.#z.length>0)this.#z.splice(0).forEach((z)=>{setTimeout(z,0)})}get waitersCount(){return this.#z.length}}export{S as WaitGroup,T as Semaphore,R as RWMutex,J as Mutex,A as Cond,q as Channel};
